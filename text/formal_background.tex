\section{Formal Background}
\label{sec:formal_background}

In this section we will introduce the formal concepts that will be used throughout all this paper. We start in \cref{sec:typed_graphs} by a few (typed) graph concepts that will be used as mathematical building blocks throughout this paper. In particular we will introduce the notion of typed graph, typed graph union and subset, and useful relations between typed graphs based on homomorphisms. Notice that these concepts are well known from graph theory and are only slightly customized for our purposes.

\reviewer{Your formalisation is made more complex than necessary because you do not put
the power of typed graphs to work. If your source and target metamodels have
disjoint types (which you can assume without loss of generality) you can take
their union, augmented with trace edge types from all target node types to all
source node types, and take that to be the meta-model for an input-output model,
and also for a rule. Suddenly you don’t have to carry arround the distinction be-
tween Match and Apply (for rules) or input and output (for input-output models)
around any more: they are just the projections onto the types of the source, resp.
target metamodel.}

\reviewer{Section 4.2.2 on “backward links” is rather confusing, as it speaks about trace-
ability links being added to rules. You never add traceability links to rules any-
where in the paper; in fact, your formal notion of a rule has no room for them.
Instead, rules only have backward links. (The clarity of the the situation is not
improved by the fact that those are labelled trace.)}

\reviewer{I think the situation would be much more clear if you were to use the common
notion of left hand side and right hand side of a rule. The left hand side of a
rule rl is precisely your ||rl||, the right hand side is the entire rl augmented by
your traceability links, as in 4.2.2. Suddenly we are back in a well-known graph
transformation formalism, and your rules are in fact so simple (no deletion, no
negative application conditions, injective matching) that I believe it makes no
difference whether you use algebraic graph transformation or some more con-
structively defined variant. The only standard notion is that of transitive closure
in the left hand side; but there are plenty of GT tools that offer this extension.
In fact I see no reason why your rule application would then not precisely coin-
cide with the the same notion in, say, SPO graph rewriting; and I hope you agree
that this would help you no end in explaining what you are doing. (If, on the
other hand, there is after all some difference then this, too, would be interesting
to know, as that difference is not at all apparent right now.)}

\reviewer{Viewed like this, moreover, I think your notions of input-output models and rules
are very close to triple graph transformation as used by Schrr at all. I think the
main (if not only) difference lies in the fact that your "glue graph" is actually not
a graph; instead, you use traceability edges directly from the target model to the
source model. If you were to turn those edges into nodes with source and target
edges, even that difference would disappear.}


Armed with the fundamental notion of typed graph, we can then introduce other formal concepts in Sections~\ref{sec:DSLTrans_formal}, \ref{sec:DSLTrans_syntax} and \ref{sec:DSLTrans_semantics} which describe the artifacts from the modeling and transformation world that we require for our verification technique. Naturally, we start by introducing the central notion of \emph{metamodel}, allowing the description of the inputs and outputs of a model transformation. Other fundamental notions we will define in this section are \emph{model}, \emph{transformation rule}, \emph{transformation} and the semantic concept of \emph{model transformation execution}. Several auxiliary and intermediate notions for defining the syntax and semantics of our techniques will also be introduced here. 

Note that this section presents a collection of formal tools that are used in the subsequent sections of this paper where the contributions of this paper are presented. It is meant as a formal reference for the upcoming formal development. This section can be safely skipped or skimmed by the reader, who can return to these definitions punctually to understand the detailed formal underpinning of our approach. 

\reviewer{There is a lot of redundancy in the paper, on several levels:
  - input-output-models, path conditions and properties are
    all defined very similarly. Couldn't you subsume them in a single
    definition and spell out the differences?}
    
\subsection{Typed Graphs}
\label{sec:typed_graphs}
% We begin this section by formally defining the graphs and graph instances used in our algorithm as fundamental structures.
% \begin{definition}{Typed Graph}
% \label{def:typed_graph}
% A typed graph is a triple $\langle V,E,\tau\rangle$ where $V$ is a finite set of
% vertices, $E\subseteq V\times V$ is a set of edges connecting the vertices and
% $\tau:V\rightarrow Type$ is a typing function for the elements of V, where $Type$ is
% a set of type names. Edges $(v,v')\in E$ are noted $v\rightarrow v'$. The set of
% all typed graphs is called $TG$.
% \end{definition}
% 
% Definition~\ref{def:typed_graph_homomorphism} describes when a typed graph is said to be homomorphic to another.
% 
% \begin{definition}{Typed Graph Homomorphism  / Typed Graph Instance}
% \label{def:typed_graph_homomorphism}
% 
% Let $\langle V,E,\tau\rangle=g,\langle V',E',\tau'\rangle=g'\in TG$ be typed
% graphs. There is a typed graph homomorphism between $g'$ and $g$ if and only if
% there exists a graph homomorphism $f:V'\rightarrow V$ such that for all $v'\in
% V$ we have that $\tau'(v')=\tau(f(v'))$. Note that, trivially, a typed graph
% homomorphism is a formal homomorphism. We denote an \emph{injective} typed graph
% homomorphism between typed graphs $g$ and $g'$ by $g' \vartriangleleft g$.
% \end{definition}
% 
% In the text that follows we will use the terms \emph{typed graph homomorphism}
% and \emph{typed graph instance} interchangeably.
% 
% Definition~\ref{def:typed_graph_strict_instance} is stricter than
% definition~\ref{def:typed_graph_homomorphism}, and indicates that there is a
% strict many-to-one type correspondence of the nodes of two graphs and their
% relations.
% 
% \begin{definition}{Typed Graph Strict Instance}
% \label{def:typed_graph_strict_instance}
% 
% Let $\langle V,E,\tau\rangle=g,\langle V',E',\tau\rangle=g'\in TG$ be typed
% graphs. $g'$ is a typed graph strict instance of $g$, noted $g'
% \blacktriangleleft g$, if and only if there exists a surjective
% typed graph homomorphism between $g'$ and $g$.
% 
% \end{definition}
% 
% In order to simplify the subsequent development we will often
% use the notation ${\langle V,E,\tau\rangle}^*$ to represent the transitive
% closure of the edges of typed graph  $\langle V,E,\tau\rangle$.

% \begin{definition}{Typed Graph}
% \label{def:typed_graph}
% A typed graph is a triple $\langle V,E,\tau\rangle$ where $V$ is a finite set of
% vertices, $E\subseteq V\times V$ is a set of edges connecting the vertices and
% $\tau:V\rightarrow Type$ is a typing function for the elements of V, where $Type$ is
% a set of type names. Edges $(v,v')\in E$ are noted $v\rightarrow v'$. The set of
% all typed graphs is called $TG$.
% \end{definition}

% \begin{definition}{Typed Graph and Indirect Typed Graph}
% \label{def:typed_graph}
% 
% A typed graph is a triple $\langle V,E,\tau\rangle$ where $V$ is a finite set of
% vertices, $E\subseteq V\times V$ is a finite set of directed edges connecting the vertices and $\tau:V\cup E \rightarrow Type\cup\{containment,reference\}$ is a typing function for the elements of V and E. Typing function $\tau$ is such that $\tau(v)\in Type$ if $v\in V$ and $\tau(e)\in \{containment,reference\}$\footnote{By using \emph{containment} and \emph{reference} as types for edges we allow modeling the different types of associations between the elements of a metamodel or a model. In particular, the fact that the subgraph of containment relations in a typed graph is acyclic models EMF containment associations.} if $e\in E$.  Edges $(v,v')\in E$ are noted $v\rightarrow v'$. We furthermore impose that the graph $\langle V,\{v\rightarrow v'\in E|\tau(v\rightarrow v')=containment\}\rangle$ is acyclic. The set of all typed graphs is called $TG$.
% 
% An indirect typed graph is a 4-tuple $\langle V,E,T,Il\rangle$, where $\langle V,E,T\rangle$ is a typed graph and $Il\subseteq E$ is a set of edges called \emph{indirect links}. The set of all indirect typed graphs is called $ITG$.
% \end{definition}

 

\CatchFileBetweenTags{\typedgraphtext}{text/definitions}{typedgraphtext}{\typedgraphtext}

\begin{definition}{Typed Graph\\}
\label{def:typed_graph}
\CatchFileBetweenTags{\typedgraph}{text/definitions}{typedgraph}{\typedgraph}
\end{definition}

\CatchFileBetweenTags{\typedgraphuniontext}{text/definitions}{typedgraphuniontext}{\typedgraphuniontext}

\begin{definition}{Typed Graph Union\\}
\label{def:typed_graph_union}
\CatchFileBetweenTags{\typedgraphunion}{text/definitions}{typedgraphunion}{\typedgraphunion}
\end{definition}

\reviewer{Graph union (Def. 2) is only well-defined if s $\cup$ s' , t $\cup$t' and $\tau \cup \tau$' yield functions,
which in turn is only the case if s and s' etc. coincide on common elements.
This is neither stated as a requirement here nor checked anywhere in the use of
the union. (Since I sure you implicitly had this restriction in mind, this may be
counted as sloppiness; you can probably assume this to hold w.l.o.g. wherever
you need it.)}
\CatchFileBetweenTags{\typedgraphhomomorphismtext}{text/definitions}{typedgraphhomomorphismtext}{\typedgraphhomomorphismtext}

\begin{definition}{Typed Graph Homomorphism\\}
\label{def:typed_graph_homomorphism}
\CatchFileBetweenTags{\typedgraphhomomorphism}{text/definitions}{typedgraphhomomorphism}{\typedgraphhomomorphism}
\end{definition}


Note that, trivially, a typed graph homomorphism is a graph homomorphism.

\reviewer{Def. 3 and all subsequent definitions g has an unexplained component st, is
this the same as the pair (s,t) in Def. 1?}

\reviewer{For multigraphs (which may contain parallel edges with the same label) it is
necessary to include edge images in the homomorphism (Def. 3). If you do not
do that, then graphs with parallel edges are isomorphic to graphs with single
edges (between the same nodes), so you might as well restrict to simple graphs.}

\reviewer{
Concretely: Right now the def. requires the existence of \textit{some} unfixed e' in the
target graph, but in fact \textit{f} should be extended to E $\rightarrow$ E' so that e' = f (e) in this
situation.
}
% \begin{lemma}{The Union of Two Typed Graph Homomorphisms is a Typed Graph Homomorphism}
% 
% Let $g=\langle V_g,E_g,st_g,\tau_g\rangle$, $g'=\langle
% V'_g,E'_g,st'_g,\tau'_g\rangle$, $h=\langle V_h,E_h,st_h,\tau_h\rangle$,
% $h'=\langle V'_h,E'_h,st'_h,\tau'_h\rangle$ be typed graphs, where $g$ and $h$
% are potentially joint, as well as $g'$ and $h'$. Let also $f:V_g\rightarrow V'_g$ and
% $i:V_h\rightarrow V'_h$ be a typed graph homomorphisms between $g$ and $g'$ and
% $h$ and $h'$, respectively. Let us show that $f\cup i$ is a typed graph homomorphism between $g\sqcup g'$ and $h\sqcup h'$.
% The proof is trivial if $g$ and $h$, as well as $h$ and $h'$ are disjoint. If $g$ and $h$ are joint over a vertex $v$, we know that $(f\cup i)(v)$
% \end{lemma}
% 
% \begin{lemma}{The Union of Two Surjective Typed Graph Homomorphisms is a Surjective Typed Graph Homomorphism}
% \levi{finish this proof}
% \end{lemma}

% \levi{changed the direction of the triangle for the surjective type graph homomorphism. Typed graph homomorphisms make sure that ALL connections between two nodes in the first graph also exists in the two mapped nodes of the second graph.}

% \begin{definition}{Strict Typed Graph Homomorphism}
% \label{def:strict_typed_graph_homomorphism}
% 
% Let $\langle V,E,\tau\rangle=g,\langle V',E',\tau\rangle=g'\in TG$ be typed
% graphs. $g'$ is a typed graph strict instance of $g$, noted $g'
% \blacktriangleleft g$, if and only if there exists a surjective
% typed graph homomorphism between $g'$ and $g$.

\CatchFileBetweenTags{\typedsubgraphtext}{text/definitions}{typedsubgraphtext}{\typedsubgraphtext}

\begin{definition}{Typed Subgraph\\}
\label{def:typedsubgraph}
\CatchFileBetweenTags{\typedsubgraph}{text/definitions}{typedsubgraph}{\typedsubgraph}

% An indirect typed graph $\langle V',E',\tau',Il\rangle \in ITG$ is an indirect typed
% subgraph of a typed graph $\langle V,E,\tau\rangle \in TG$, written $\langle
% V',E',\tau',Il\rangle \lhd \langle V,E,\tau\rangle$ iff:
% 
% \begin{enumerate}
% \item $\langle V',E'\setminus Il,\tau'\rangle \blacktriangleleft \langle V, E,\tau\rangle$
% \item if $v_i\rightarrow v_i'\in Il$ then there exists $v\rightarrow v'\in E_{c}^{*}$ where $\tau(v_i)=\tau(v)$, $\tau(v_i')=\tau(v')$ and $E_{c}^{*}$ is obtained by the transitive closure of $E_{c}=\{v\rightarrow v'\in E|\tau(v\rightarrow v')=containment\}$.
% \end{enumerate}
\end{definition} 

\CatchFileBetweenTags{\typedgraphisomorphismtext}{text/definitions}{typedgraphisomorphismtext}{\typedgraphisomorphismtext}

\begin{definition}{Typed Graph Isomorphism\\}
\label{def:typed_graph_isomorphism}
\CatchFileBetweenTags{\typedgraphisomorphism}{text/definitions}{typedgraphisomorphism}{\typedgraphisomorphism}
\end{definition}
% \begin{definition}{Typed Graph Connected Component}
% \label{def:typed_graph_connected_component}
% 
% Let $g \in \textsc{TG}$ be a typed graph. We say that $\langle V,E,st,\tau\rangle \sqsubseteq g$ is a connected component of $g$ if for any pair of vertices $v,v'\in V$ there exists a path between $v$ and $v'$, where the direction of the edges between $v$ and $v'$ does not matter.
% \end{definition}

% \begin{definition}{Typed Graph Instance}
% \label{def:typed_graph_instance}
% 
% Let $\langle V,E,\tau\rangle=g,\langle V',E',\tau\rangle=g'\in TG$ be typed graphs.
% $g'$ is a typed graph instance of $g$, written $g'\Vdash g$, iff for all $v_{1}'\rightarrow v_{2}'\in E'$ there is a $v_{1}\rightarrow v_{2}\in E$ such that $\tau(v_{1}')=\tau(v_1)$, $\tau(v_{2}')=\tau(v_2)$ and $\tau(v_{1}'\rightarrow v_{2}')=\tau(v_{1}\rightarrow v_{2})$.
% \end{definition}

%Notice that we only enforce that connections between vertices of $g'$ must exist also in $g$ and have the same type.

% \levi{Note that each edge between two nodes in the first graph has to exist in the second graph and vice-versa.}
% \levi{in the sections that follow we will formally elaborate on relevant concepts that are introduced.}

\paragraph{\textbf{Notation:}}
\CatchFileBetweenTags{\notationformalbackground}{text/definitions}{notationformalbackground}{\notationformalbackground}

\subsection{Metamodel and Model-Related Constructs}
\label{sec:DSLTrans_formal}

% This section will formally describe the DSLTrans constructs that are required in
% our property-proving algorithm. The definitions presented strongly rely on the concepts of typed graphs, just introduced in \cref{sec:typed_graphs}.

We will start by introducing the notion of \emph{metamodel}, which in DSLTrans is used to type the input and output models of a DSLTrans transformation.  Two metamodels, the \emph{organization language} and \emph{gender language} are depicted in \cref{fig:squadmetamodel}.

\begin{definition}{Metamodel\\}
\label{def:metamodel}
\CatchFileBetweenTags{\metamodel}{text/definitions}{metamodel}{\metamodel}
\end{definition}

\reviewer{Def. 6: Since the codomain of $\tau$ is apparently VT $\times$ {abstract, concrete} $\cup$ ET $\times$
{containment, reference}, it is certainly never going to be a bijection. However,
I think you actually only want injectiveness; what purpose is served by requiring
it to be surjective?}

\reviewer{As an aside, I think this is quite an awkward way to encode the notions of ab-
stractness and containment: I think it would be much more elegant to define
abstractness as a predicate over VT and containment as a predicate over ET. To
go even one step further, it would in fact be more natural (and more standard)
to equate the notions of type graph and metamodel altogether, as they certainly
serve the same conceptual purpose.
}

\reviewer{Def. 6 and many other places A word in math mode should always
be in $\backslash$mathit to avoid ugly spacing as in $re f erence$.}

\CatchFileBetweenTags{\metamodeltext}{text/definitions}{metamodeltext}{\metamodeltext}

\begin{definition}{Expanded Metamodel\\}
\label{def:expanded_metamodel}
\CatchFileBetweenTags{\expandedmetamodel}{text/definitions}{expandedmetamodel}{\expandedmetamodel}
\end{definition}

\reviewer{Def. 7: is an expanded metamodel a metamodel? Then you need to allow non-
injective $\tau$, at least on edges, as the requirement $\tau$(e) = $\tau$(e') in the third bullet
will certainly cause non-inejectiveness.}


\CatchFileBetweenTags{\expandedmetamodeltext}{text/definitions}{expandedmetamodeltext}{\expandedmetamodeltext}

\begin{definition}{Metamodel Instance\\}
\label{def:metamodelinstance}
\CatchFileBetweenTags{\metamodelinstance}{text/definitions}{metamodelinstance}{\metamodelinstance}
\end{definition}

\CatchFileBetweenTags{\metamodelinstancetext}{text/definitions}{metamodelinstancetext}{\metamodelinstancetext}


\reviewer{Def. 9 and many thereafter incrementally define new concepts on top of graphs.
Most of these definitions are rather hard to read, for several reasons:}

\begin{itemize}
\item It is common to use an unprimed version for the original object and a
primed version for the constructed object, whereas you turn this conven-
tion around
%\item Sloppiness: in more than 50 percent of all cases the ⊆ should be ⊇ or vice versa;
%in this particular instance, you really mean τ ′ ⊇ τ and E = E ′ ∪ E c ∗ .

\item It is really more readable to define the construction as a construction, so:
\begin{itemize}
\item  $E = E'\cup E^{\star}_{C}$
\item $s = s' \cup {(e_1 \dots e_n , s(e_1)) | e_1 \dots e_n \in E^{\star}_{C} }$
\item $t = t' \cup {(e_1 \dots e_n ,t(e_n )) | e_1 \dots e_n \in E^{\star}_{C} }$
\item $\tau = \tau' \cup {(e, indirect) | e \in E^{\star}_{C} }$
\end{itemize}
\begin{itemize}
\item Note that this also takes care of s and t, which you have forgotten here
and in all other similar definitions.)
\item The set $E^{\star}_{C}$should itself also be more carefully defined, as $E^{\star}_{C} = {e_1 \dots e_n \in E^∗' | \forall1 \leq i < n.t(e_i ) = s(e_{i+1} )}$
\end{itemize}
\end{itemize}


\begin{definition}{Containment Transitive Closure\\}
\label{def:instance_closure}
\CatchFileBetweenTags{\instanceclosure}{text/definitions}{instanceclosure}{\instanceclosure}

\end{definition}

\CatchFileBetweenTags{\instanceclosuretext}{text/definitions}{instanceclosuretext}{\instanceclosuretext}



\begin{definition}{Model\\}
\label{def:model}
\CatchFileBetweenTags{\model}{text/definitions}{model}{\model}
\end{definition}

\reviewer{Def. 10: Here you certainly should not require $\tau$ to be injective. The requirement
on containment relations is mathematical nonsense: if $e' \in E'$ has target b then
$b \in V'$ and so f (b) does not exist, and most certainly is not the source of any edge
in E. In fact, I really have no idea what you want to say here; the explanation
below the definition does not clarify matters at all.}


\CatchFileBetweenTags{\modeltext}{text/definitions}{modeltext}{\modeltext}


\reviewer{“the cardinality of the target class”?? Are you talking about edge multiplicities here (which you have chosen not to include)?}


\begin{definition}{Input-Output Model\\}
\label{def:input_output_model}
\CatchFileBetweenTags{\inputoutputmodel}{text/definitions}{inputoutputmodel}{\inputoutputmodel}
\end{definition}

\reviewer{Why is Input a model and Output a metamodel instance? Note that
$\backslash$ binds stronger than $\cup$ in $E \backslash E' \cup E$ ′′ . “match-apply patterns” → “input-output
patterns”}
%Change if needed
\CatchFileBetweenTags{\inputoutputmodeltext}{text/definitions}{inputoutputmodeltext}{\inputoutputmodeltext}

\begin{definition}{Metamodel Pattern and Indirect Metamodel Pattern\\}
\label{def:metamodel_pattern} 
\CatchFileBetweenTags{\metamodelpattern}{text/definitions}{metamodelpattern}{\metamodelpattern}
\end{definition}

\CatchFileBetweenTags{\metamodelpatterntext}{text/definitions}{metamodelpatterntext}{\metamodelpatterntext}


\subsection{Syntactic Transformation Constructs}
\label{sec:DSLTrans_syntax}

This section will detail the abstract syntax of the constructs involved in a DSLTrans transformation.

\begin{definition}{Transformation Rule\\}
\label{def:transformation_rule}
\CatchFileBetweenTags{\transformationrule}{text/definitions}{transformationrule}{\transformationrule}
\end{definition}

\reviewer{e in $\tau(e) = \mathit{trace}$ is still bound by $\nexists$, so “and” should be $\land$}

\CatchFileBetweenTags{\transformationruletext}{text/definitions}{transformationruletext}{\transformationruletext}


\begin{definition}{Matcher of a Transformation Rule\\}
\label{def:back_match_transformation_rule}
\CatchFileBetweenTags{\backmatchtransformationrule}{text/definitions}{backmatchtransformationrule}{\backmatchtransformationrule}
\end{definition}

\reviewer{Def. 14: According to your own criterion, $||rl||$ is not a rule as it does not create
either a node or an edge.}


\Cref{def:back_match_transformation_rule} \CatchFileBetweenTags{\backmatchtransformationruletext}{text/definitions}{backmatchtransformationruletext}{\backmatchtransformationruletext}


\begin{definition}{Expanded Transformation Rule\\}
\label{def:transformation_rule_expansion}
\CatchFileBetweenTags{\expandedtransformationrule}{text/definitions}{expandedtransformationrule}{\expandedtransformationrule}
\end{definition}

\reviewer{The first bullet is a special case of the second, so can be removed.}
\CatchFileBetweenTags{\expandedtransformationruletext}{text/definitions}{expandedtransformationruletext}{\expandedtransformationruletext}

\begin{definition}{Layer, Model Transformation\\}
\label{def:layer_transformation}
\CatchFileBetweenTags{\layertransformation}{text/definitions}{layertransformation}{\layertransformation}
\end{definition}

\reviewer{The second half of Def. 16 raises a lot of questions. First of all, neither $\sqsubseteq 	 $ nor
$\cong$ are defined over rules; however, I can imagine what it would look like. Then,
what role does rl play; do you just mean $||rl_1 || \sqsubseteq ||rl_2 ||$ given a suitable isomorphic copy? What if $||rl_1 || \cong ||rl_2 || $(as a special case); is your condition then not
unsatisfiable as $rl_1$ must appear after $rl_2$ as well as vice versa?}


\reviewer{More importantly though, why do you care? Your semantics makes sure that
rules are never considered for application twice in succession, so dependencies
are always resolved unambiguously.}

\CatchFileBetweenTags{\layertransformationtext}{text/definitions}{layertransformationtext}{\layertransformationtext}

\paragraph{\textbf{Notation:}}

\CatchFileBetweenTags{\notationtext}{text/definitions}{notationtext}{\notationtext}


% We naturally extend the notion of union (definition~\ref{def:typed_graph_union})
% to models (definition~\ref{def:metamodelmodel}), match-apply models
% (definition~\ref{def:match_apply_model}) and transformation rules 
% (definition~\ref{def:transformation_rule}). We also extend the notion of
% indirect typed subgraph (definition~\ref{def:indirecttypedsubgraph}) to
% transformation rules (definition~\ref{def:transformation_rule}) and match-apply
% models (definition~\ref{def:match_apply_model}). Finally, we extend the notion
% of typed graph equivalence (definition~\ref{def:typed_graph_equivalence}) to
% transformation rules (definition~\ref{def:transformation_rule}).

% \subsubsection{Transformation Language Semantics}
% 
% We will now address the semantics of the DSLTrans language. We will start by defining a match function that, given an input-output model and a transformation rule, returns all subgraphs of that input-output model where the rule's match pattern (including backward links) is found.  
% 
% % \levi{Need to be careful throughout all this section to understand whether we model the match and apply functions as functions or relations. Because of the non-deterministic generation of new vertices in the definition of apply function~\ref{def:apply_function}, relations are used in the definitions that follow to evaluate a transformation. This is an issue of the formalism used to model, should we make it explicit?}
% 
% \begin{definition}{Match Function}
% \label{def:match_function}
% 
% Let $m_{in}\in \textsc{Iom}^{sr}_{tr}$ be a input-output model and $rl\in \textsc{Rule}^{sr}_{tg}$ be a transformation
% rule. The $match : \textsc{Iom}^{sr}_{tg}\times \textsc{Rule}^{sr}_{tg}\rightarrow
% \mathcal{P}(\textsc{Iom}^{sr}_{tg})$ function is defined as follows: $$match_{rl}(m_{in})= \big\{ glue_{noind}\;|\;
% glue\sqsubseteq m_{in}^{*} \land glue \cong rl^{backM}_{trace}\big\}$$
% 
% where $glue$ is an input-output model. Additionally we have that: $rl_{trace}$ is a version of $rl$ where edges of type \emph{backward} have been replaced by edges of type \emph{trace}; $glue_{noind}$ is a version of $glue$ where the indirect links have been removed.
% % \levi{all backward links are replaced by trace links such that the matching using subgraph isomorphim can work.}
% % 
% % \levi{Where $rl^{-}$ is rule $rl$ without nodes in the apply part that are not connected to \emph{trace links}, as well as links adjacent to those nodes. $mg^{-ind}$ is the match graph without indirect links that come from the rule, given those cannot be part of the intermediate $MAM$ match result since that result is going to be united with the original $MAM$ (this was incorrect in the original SLE paper).}
% % \levi{The matcher function returns all graphs of the input MAM that are matched by a rule, including its backward links. Note that to find a subgraph ($\sqsubseteq$) of the input MAM that is isomorphic ($\cong$) to the rule being matched because the graph rewriting is achieved by joint union of the match graph extended by the new rewrite node, and the original MAM.}
% % \levi{TODO: review the $mg^{-ind}$ and the $rl^{-}$ notations.}
% 
% % Due to the fact that the $\cong$ relation is based on the notion of graph
% % isomorphism, permutations of the same match result may exist in the
% % $\big\{g\;|\; g\lhd m \land g \cong strip(tr)\big\}$ set. The --- undefined ---
% % $remove:\mathcal{P}(TR^{s}_{t})\rightarrow \mathcal{P}(TR^{s}_{t})$ function is such that
% % it removes such undesired permutations.
% 
% %The $strip:TR^{s}_{t}\rightarrow TR^{s}_{t}$ function is such that
% %$$strip(\big\langle V,E,T,\langle V_m,E_m,T_m,s\rangle,\langle V_a,E_a,T_a,t\rangle,Bl,Il\big\rangle) = \big\langle V',E',T,\langle V_m,E_m,T_m\rangle,\langle V'_a,E'_a,T_a\rangle,Bl,Il\big\rangle$$
% %\begin{center}
% %where $(v'\in V'_a\Rightarrow v\rightarrow v'\in Bl)\;\land\;(v\rightarrow v'\in E'_a\Rightarrow (v\rightarrow v'\in E_m \land \{v,v'\}\subseteq V'_a))$
% %\end{center}
% \end{definition}
% 
% The match function in definition~\ref{def:match_function} looks for subgraphs ($glue\sqsubseteq m_{in}^{*}$) of an input-output model that are isomorphic to the backward matcher of the given transformation rule ($glue \cong rl^{backM}_{trace}$). Note that the containment transitive closure of the input-output model ($m_{in}^{*}$) is considered such that indirect links in the rule can looked for. Additionally, indirect links need to be removed from the input-output models resulting from the match function ($glue_{noind}$). This is do because indirect links are not part of the original input model but rather an auxiliary structure.
% 
% Let us now turn our attention to the apply function in definition~\ref{def:apply_function}. Its role is extend each of the sub-models found by the a match function for a given input-output model and a given transformation rule, such that they become isomorphic to the complete rule (minus its backward links). This process effectively creates the new objects and relations specified in the apply part of the rule for each of the sub-models found by the match function.
% 
% \begin{definition}{Apply Function}
% \label{def:apply_function}
% 
% Let $m_{glue}\in \textsc{Iom}^{sr}_{tg}$ be a input-output model and $rl\in \textsc{Rule}^{sr}_{tg}$ a
% transformation rule. The $apply : \textsc{Iom}^{sr}_{tg}\times \textsc{Rule}^{sr}_{tg}\rightarrow \textsc{Iom}^{sr}_{tg}$ function
% is defined as follows: 
% 
% $$apply_{rl}(m_{in})=\bigsqcup_{m_{glue}\in match_{rl}(m_{in})}trace_{a_{\Delta}}(m_{glue}\sqcup a_{\Delta})$$
% 
% \begin{center}
% where $a_{\Delta}\in \textsc{Iom}^{sr}_{tg}$ is such that $m_{glue} \sqcup a_{\Delta}\cong rl_{noind}$.\\
% \end{center}
% 
% We impose that any instance of $a_\Delta$ is always disjoint from the $m_{in}$
% input-output model and also that any two instances of $a_\Delta$ used in the
% large union are always disjoint. Partial function $trace:\textsc{Iom}\times
% \textsc{Iom} \nrightarrow \textsc{Iom}$ is such that $trace_{\langle
% V_{\Delta},E_{\Delta},st_{\Delta},\tau_{\Delta}\rangle}(\langle
% V,E,st,\tau\rangle) = \langle V,E',st',\tau'\rangle$ where we have that
% $E\subseteq E'$, $st\subseteq st'$ (using a light notational abuse for the $s\subseteq s'$
% and $t\subseteq t'$), $\tau \subseteq \tau'$ and if $v_1\xrightarrow{e}
% v_2\in E'\setminus E$ then $v_1\in Output(V_{\Delta})$, $v_2\in Input(V)$ and
% $\tau'(e)=trace$. Finally, $rl_{noind}$ is a version of $rl$ where indirect
% links have been removed.
% % More concretely, if we have $mam = $\big\langle V,E,st,\tau, Input,Output\big\rangle\in MAM^{sr}_{tg}$ where $Input=\langle V',E',st',\tau'\rangle\in MODEL^{sr}$ and $Output=\langle
% % V'',E'',st'',\tau''\rangle\in MODEL^{tg}$, then $trace(mam) = \big\langle V,E,st,\tau''',Input,Output\big\rangle$ where $E'\subseteq E$ and $v\rightarrow E'\setminus E$ 
% \end{definition}
% % 
% % it builds traceability edges between vertices of the output model that were newly built by the $apply$ function (the vertices in ${mg}_{\Delta}$) and all the vertices from the input part of the input-output model. It is necessary to remove the indirect links from the rule because otherwise they would be created during the rewriting by the apply function. 
% 
% In definition~\ref{def:apply_function} $a_\Delta$ is an input-output model that contains an instance of the target metamodel. These instances are created by rule $rl$ and are used to extend the sub-models found by the match function. The $trace$ function builds traceability edges between vertices of the output model in $a_{\Delta}$ and all the vertices from the input part of a model fragment found by the match function.
% 
% Note that, because we do not pose any constraints on $a_\Delta$ other than the fact that its union with the sub-model $m$ is isomorphic to $rl_{noind}$, the $a_\Delta$ variable can always be satisfied by an unlimited amount of input-output models. In order to avoid an infinite amounts of results when a transformation rule is executed, in what follows we will consider transformation results differ only up to typed graph isomorphism.   
% 
% %  Note that because the vertices are not disjoint, when the graph produced by the apply function is united with the original match apply model the new vertices are created. It was necessary to remove the indirect links from the rule during rewriting, because otherwise those indirect links would also be rewritten.
% 
% Definitions~\ref{def:match_function} and~\ref{def:apply_function} are complementary: the former gathers all the sub-models of an input-output model that are matched by a transformation rule; the latter glues on the output part of each of those sub-models new objects and relations created by a transformation rule. 
% 
% %  The $strip$ function is used to
% %  enable matching over backward links but not elements to be created by the
% %  transformation rule. The $back$ function connects all newly created vertices
% %  to the elements of the source model that originated them.
% 
% %\begin{definition}{Transformation}
% 
% %Let $g\in TG$ be a typed graph. The graph transform function $transform : TR\times TG\rightarrow TG$ is recursively defined as:
% %\begin{gather*}
% %  transform_{(m,a)}(g) =
% %  \begin{cases}
% %    g  & \text{if } match_{m}(g)=\emptyset \\
% %    instance(a)\cup transform_{(m,a)}(g') &\text{if } match_{m}(g)\neq \emptyset
% %  \end{cases}
% %\end{gather*}
% %$$\text{where } g'=mark_{(m)}(g)$$
% %\end{definition}
% 
% %\subsection{Transformation Semantics}
% %\begin{definition} {Layer Semantics}
% 
% %Let $l\in Layer$ be a layer and $\{m,m'\} \in MAM^{s}_{t}$ be a match
% %$$\frac{}
% %{m,\emptyset \stackrel{layerstep}{\rightarrow}m}$$
% %$$\frac{tr\in layer,\; transform_{tr}(m) = m''\; m'',layer\backslash\left\{tr\right\} \xrightarrow{layerstep}	 m'}{m,layer \xrightarrow{layerstep} m'}$$
% %\end{definition}
% 
% \begin{definition} {Layer Step Semantics}
% \label{def:layer_step_semantics}
% 
% Let $l\in \textsc{Layer}^{sr}_{tg}$ be a Layer. The \emph{layer step relation}
% $\stackrel{layerstep}{\rightarrow}\subseteq \textsc{Iom}^{sr}_{tg}\times \textsc{Iom}^{sr}_{tg} \times \textsc{Layer}^{sr}_{tg}\times
% \textsc{Iom}^{sr}_{tg}$ is defined as follows:
% 
% $$\frac{}
% {\langle m_{in},m_{glue},\epsilon\rangle \xrightarrow{layerstep}m_{in} \sqcup m_{glue}}$$
% 
% $$\frac{\begin{array}{ll}& rl\in l,\; apply_{rl}(m_{in}) = m_{rout},
% \langle m_{in},m_{glue}\sqcup m_{rout},l\backslash \{rl\}\rangle \xrightarrow{layerstep} m_{out}
% \end{array}}
% {\langle m_{in},m_{glue},l\rangle \xrightarrow{layerstep} m_{out}}$$
% 
% \begin{center}
% where $m_{rout} \in\textsc{Iom}^{sr}_{tg}$ and $rl\in \textsc{Rule}^{sr}_{tg}$.
% \end{center}
%  
% We impose that all input-output models that are part of $rout$ and have been generated by rule $rl$ are disjoint from input-output models accumulated in $m_{glue}$ that have been generated by other rules.
% 
% \end{definition}
% 
% In definition~\ref{def:layer_step_semantics} we build the result of executing a layer of a DSLTrans transformation. The operational semantics-like rules in the definition execute each rule $rl$ in layer $l$, in a non-deterministic order, by using the $apply$ function. The result of executing each rule is accumulated in the temporary $m_{glue}$ input-output model. Finally, when the set of transformation rules in the layer has been exhausted, the result of executing all the rules in the layer (now contained in $m_{glue}$) is united with the input-output model $m_{in}$, the input to layer $l$. Note that this final union produces the result we expect because of the fact that the $m_{glue}$ input-output model is not disjoint from $m_{in}$. The common ``glue'' parts of $m_{glue}$ that have been built by the match function and extended by the apply function are now used to built the result of executing layer $l$.
% 
% Definition~\ref{def:layer_step_semantics} is the core of DSLTrans' semantics. Many model transformation languages are based on graph rewriting, where the result of each rule rewrite is immediately usable by all other rules. In DSLTrans the result of executing one layer in DSLTrans is totally produced before the input to the layer is changed. This is enforced in definition~\ref{def:layer_step_semantics} by the fact that the apply function always executes over the same $m_{in}$ input-output model and all the results of rule execution in the same layer are added to the $m_{glue}$ structure that is write-only. Rules belonging to the same layer are thus forced to execute independently.
% 
% 
% \begin{definition} {Transformation Step Semantics}
% \label{def:transformation_step_semantics}
% 
% Let $[l::tr]\in \textsc{Transf}^{sr}_{tg}$ be a transformation, where $l\in
% \textsc{Layer}^{sr}_{tg}$ is a Layer and $tr$ also a transformation. The \emph{transformation step relation}
% $\stackrel{trstep}{\rightarrow}\subseteq \textsc{Iom}^{sr}_{tg}\times \textsc{Transf}^{sr}_{tg}\times
% \textsc{Iom}^{sr}_{tg}$ is defined as follows: 
% $$\frac{}{\langle m,[]\rangle \xrightarrow{trstep} m}$$
% 
% $$\frac{\big\langle m_{in},\epsilon,l^{\star}\big\rangle \xrightarrow{layerstep} m_{inter},\; \langle m_{inter},R\rangle \xrightarrow{trstep} m_{out}}{\langle m_{in},[l::T]\rangle \xrightarrow{trstep} m_{out}} \hspace{.3cm} \text{where} \hspace{.3cm} l^{\star}=\bigcup_{rl\in l}rl^{\star}$$
% \end{definition}
% 
% While the execution of the rules belonging to a layer happens in parallel, the execution of the layers of a transformation happens sequentially. 
% As per definition~\ref{def:transformation_step_semantics}, the input-output model $m_{inter}$ is the output of executing a given layer that is passed onto the next layer as input. The transformation rules in a layer are expanded before execution ($l^{\star}$) such that polymorphism in match elements can be handled (see definition~\ref{def:transformation_rule_expansion}). 

\subsection{Semantic Transformation Constructs}
\label{sec:DSLTrans_semantics}

In the definition that follows we introduce the notion of execution of a DSLTrans model transformation. For our purposes it is sufficient to introduce it as an input-output model (see \cref{def:input_output_model}), containing the input model for the transformation, the produced output, and the traceability links built during execution. Due to space limitations, we cannot introduce the semantics of DSLTrans in the main text of this paper. We thus refer the reader to \cref{sec:DSLTrans_formal} for a formal description on how DSLTrans transformation executions are built. 

\reviewer{Definition 17: There is a copy/paste error w.r.t. Def. B.16 (which only serves to
strengthen my point, made above, about avoiding this kind of duplication). In
this case, B.16 is the correct version.}

\begin{definition} {Model Transformation Execution\\}
\label{def:modeltransformation} 
\CatchFileBetweenTags{\modeltransformation}{text/definitions}{modeltransformation}{\modeltransformation}
\end{definition}

\CatchFileBetweenTags{\modeltransformationtext}{text/definitions}{modeltransformationtext}{\modeltransformationtext}

% A transformation execution is formed from taking the input model, and executing
% the transformation on it to produce the output model. During this
% transformation, traceability links will be placed between match elements and the
% apply elements they create. Definition~\ref{def:transf_ex} expresses this
% formally. Note that we assume that transformation executions are built following
% the algorithm described in~\cite{DBLP:conf/sle/BarrocaLAFS10}.

% \begin{definition}{Transformation Execution}
% \label{def:transf_ex}
% 
% Let $t$ be a DSLTrans transformation having source metamodel $s$ and target
% metamodel $t$. A Transformation Execution is a 6-tuple $\langle V,E\cup
% Tl,\tau,Match,Apply,Tl\rangle$, where $\langle V,E,\tau,Match,Apply\rangle \in
% MAP^{s}_{t}$ is a match-apply pattern. $Match=\langle V',E', \tau',s\rangle$,
% $Apply=\langle V'',E'', \tau'',t\rangle$ and the edges $Tl\subseteq V'\times
% V''$ are called \emph{traceability links}. The set of all transformation
% executions having source metamodel $s$ and target metamodel $t$ is called
% $Exec^{s}_{t}$.
% \end{definition}

% We now prove two important properties about DSLTrans' transformations.
% 
% \begin{proposition}{Confluence}
% 
% Every model transformation is confluent up to typed graph isomorphism.
% \end{proposition}
% 
% \begin{proposition}{Termination} 
% 
% Every model transformation terminates.
% \end{proposition}


% The language to describe properties is in fact very similar to the language to
% express transformations, with the additional possibility of expressing indirect
% links in the $apply$ pattern --- thus allowing more abstract patterns than the
% ones expressed in transformations. This is natural given that the properties of
% a transformation can be more abstract than the rules implementing them.
