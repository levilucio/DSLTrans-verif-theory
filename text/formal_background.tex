\section{Formal Background}
\label{sec:formal_background}

In this section we will introduce the formal concepts that will be used throughout all this paper. We start in \cref{sec:typed_graphs} by a few (typed) graph concepts that will be used as mathematical building blocks throughout this paper. In particular we will introduce the notion of typed graph, typed graph union and subset, and useful relations between typed graphs based on homomorphisms. Notice that these concepts are well known from graph theory and are only slightly customized for our purposes.

\reviewer{Your formalisation is made more complex than necessary because you do not put
the power of typed graphs to work. If your source and target metamodels have
disjoint types (which you can assume without loss of generality) you can take
their union, augmented with trace edge types from all target node types to all
source node types, and take that to be the meta-model for an input-output model,
and also for a rule. Suddenly you don’t have to carry arround the distinction be-
tween Match and Apply (for rules) or input and output (for input-output models)
around any more: they are just the projections onto the types of the source, resp.
target metamodel.}

\reviewer{Section 4.2.2 on “backward links” is rather confusing, as it speaks about trace-
ability links being added to rules. You never add traceability links to rules any-
where in the paper; in fact, your formal notion of a rule has no room for them.
Instead, rules only have backward links. (The clarity of the the situation is not
improved by the fact that those are labelled trace.)}

\reviewer{I think the situation would be much more clear if you were to use the common
notion of left hand side and right hand side of a rule. The left hand side of a
rule rl is precisely your rule matcher, the right hand side is the entire rl augmented by
your traceability links, as in 4.2.2. Suddenly we are back in a well-known graph
transformation formalism, and your rules are in fact so simple (no deletion, no
negative application conditions, injective matching) that I believe it makes no
difference whether you use algebraic graph transformation or some more con-
structively defined variant. The only standard notion is that of transitive closure
in the left hand side; but there are plenty of GT tools that offer this extension.
In fact I see no reason why your rule application would then not precisely coin-
cide with the the same notion in, say, SPO graph rewriting; and I hope you agree
that this would help you no end in explaining what you are doing. (If, on the
other hand, there is after all some difference then this, too, would be interesting
to know, as that difference is not at all apparent right now.)}

\reviewer{Viewed like this, moreover, I think your notions of input-output models and rules
are very close to triple graph transformation as used by Schrr at all. I think the
main (if not only) difference lies in the fact that your "glue graph" is actually not
a graph; instead, you use traceability edges directly from the target model to the
source model. If you were to turn those edges into nodes with source and target
edges, even that difference would disappear.}


Armed with the fundamental notion of typed graph, we can then introduce other formal concepts in Sections~\ref{sec:DSLTrans_formal}, \ref{sec:DSLTrans_syntax} and \ref{sec:DSLTrans_semantics} which describe the artifacts from the modeling and transformation world that we require for our verification technique. Naturally, we start by introducing the central notion of \emph{metamodel}, allowing the description of the inputs and outputs of a model transformation. Other fundamental notions we will define in this section are \emph{model}, \emph{transformation rule}, \emph{transformation} and the semantic concept of \emph{model transformation execution}. Several auxiliary and intermediate notions for defining the syntax and semantics of our techniques will also be introduced here. 

Note that this section presents a collection of formal tools that are used in the subsequent sections of this paper where the contributions of this paper are presented. It is meant as a formal reference for the upcoming formal development. %This section can be safely skipped or skimmed by the reader, who can return to these definitions punctually to understand the detailed formal underpinning of our approach. 

\reviewer{There is a lot of redundancy in the paper, on several levels:
  - input-output-models, path conditions and properties are
    all defined very similarly. Couldn't you subsume them in a single
    definition and spell out the differences?}


\newcommand{\defineggprime}{Let $\langle V,E,(s,t),\tau,VT,ET\rangle = g$, and\\ $\langle V',E',(s',t'),\tau',VT',ET'\rangle = g'$, where $g, g' \in \textsc{TG}$.}

\newcommand{\ET}{\mathit{ET}}
\newcommand{\VT}{\mathit{VT}}


\bentley{Make sure that terminology is consistent between elements and vertices}

\subsection{Typed Graphs}
\label{subsec:typed_graphs}


\subsubsection*{Typed Graph}
We will start by introducing the notion of typed graph. A typed graph is the essential object we will use throughout our mathematical development. Typed graphs will be used to formalise all the important graph-like structures we will present in this paper. A typed graph is a directed multigraph (a graph allowing multiple edges between two vertices) where vertices and edges are typed.


\begin{definition}{Typed Graph\\}
\label{def:typed_graph}
A typed graph is a 6-tuple $\langle V,E,(s,t),\tau, \VT, \ET\rangle$ where:
\begin{itemize}
\item $V$ is a finite set of vertices
\item $E$ is a finite set of directed edges connecting the vertices $V$
\item $(s,t)$ is a pair of functions $s: E\rightarrow V$ and $t: E\rightarrow V$ that respectively provide the source and target vertices for each edge in the graph
\item Function $\tau:V\cup E\rightarrow \VT \cup \ET$ is a typing function for the elements of $V$ and $E$, where $\VT$ and $\ET$ are disjoint finite sets of vertex and edge type identifiers and $\tau(v)\in \VT$ if $v\in V$ and $\tau(e)\in \ET$ if $e\in E$
\item Edges $e\in E$ are noted $v\xrightarrow{e} v'$ if $s(e)=v$ and $t(e)=v'$, or simply e if the context is unambiguous
\item The set of all typed graphs is called $\textsc{TG}$
\item We define the empty graph to be a graph with all elements to be empty functions or sets
\end{itemize}
\end{definition}


\subsubsection{Vertex and Edge Types}

Note that the our verification technique is geared toward model-driven engineering. Therefore, the types of vertices and edges in our typed graphs will be drawn from a particular \textit{metamodel}. Sample metamodels for our running example can be seen in figures above \bentley{Fix.}. Note that DSLTrans rules (to be formally defined) will combine typed graphs with potentially different metamodels.

We assume that this metamodel provides the necessary vertex and edge types, with any collisions resolved by adding to the metamodel name. As well, we assume the presence of a partial ordering $\leq$ on the vertex and edge types for subtyping information.

For convenience, we define some utility functions in our formalization to aid the treatment of typing:

\begin{itemize}
\item $\mathit{isAbstract}: \mathit{VT} \rightarrow \{\mathit{true}$, $\mathit{false}\}$
\begin{itemize}
\item Where $\mathit{isAbstract}(\VT)$ returns $\mathit{true}$ iff $\VT$ is denoted as abstract (not able to be instantiated) by the metamodel, else $\mathit{false}$
\end{itemize}

\item $\mathit{isIndirect}: \mathit{ET} \rightarrow \{\mathit{true}$, $\mathit{false}\}$
\begin{itemize}
\item Where $\mathit{isIndirect}(\ET)$ returns $\mathit{true}$ iff $\ET$ is denoted as an \textit{indirect edge}, else $\mathit{false}$. The \textit{indirect} classification allows matching over indirect paths between vertices. This will be further clarified when required for our constructs.
\end{itemize}

\item $\mathit{matchesOver}: \{\VT \cup \ET\} \times \{\VT \cup \ET\} \rightarrow \{\mathit{true}$, $\mathit{false}\}$

\begin{itemize}
\item The purpose of this function is to assist in handling polymorphism in the metamodel, and to handle matching for the special DSLTrans types
\item $\mathit{matchesOver}(T, T) \rightarrow \mathit{true}$
\item $\mathit{matchesOver}(T, T') \rightarrow \mathit{true}$ iff T' is a subclass of T in some defined partial ordering $\leq$ given by the metamodel
\item Otherwise, $\mathit{false}$
\end{itemize}
\end{itemize}

This typing information is our implementation of a typed graph conforming to a metamodel. Note that for simplification purposes, we will not represent edge cardinalities or containment relationships given by a metamodel in our notion of typed graph. In fact we require these conditions to be relaxed to perform our graph rewriting.

\subsubsection*{Typed Subgraph}
We now define the useful notion of typed subgraph. As expected, a typed subgraph is simply a restriction of a typed graph to some of its vertices and edges. This will be needed to partition DSLTrans constructs such as rules into logical components.

\begin{definition}{Typed Subgraph\\}
\label{def:typedsubgraph}
\defineggprime

$g'$ is a typed subgraph of $g$, written $g'\sqsubseteq g$, iff $V'\subseteq V$, $E'\subseteq E$ and $\tau'=\tau |_{V'\cup E'}$.

\end{definition}

%Given a typed graph $g\in \textsc{TG}$, will use the notation $Components(g)$ to describe the set of strongly connected typed graphs in $g$. Also, we will use the notation $g|_{t}$ to refer to the restriction of graph $g$ to its subgraph containing only edges of type $t$.

We also define a function getEdges: \textit{ET} $\rightarrow$ Set(Edges) to return all edges of a certain edge type.

\bentley{Where is this used?}

\subsubsection*{Typed Graph Union}
We now define how two typed graphs are united. A union of two typed graphs is trivially the set union of all the components of those two typed graphs. Note that we do not require the components of the two graphs to be disjoint, as in the following joint unions will be used to merge typed graphs.

\begin{definition}{Typed Graph Union\\}
\label{def:typed_graph_union}

The typed graph union is the function $\sqcup :\textsc{TG}\times \textsc{TG}\rightarrow \textsc{TG}$ defined as:
\begin{multline*}
\big\langle V,E,(s,t),\tau,\VT,\ET\big\rangle\;\sqcup\;\big\langle V',E',(s',t'),\tau',\VT',\ET'\big\rangle=\\
\big\langle V\cup V', E\cup E',(s\cup s', t\cup t'), \tau\cup \tau', \VT\cup \VT', \ET\cup ET'\big\rangle
\end{multline*}
\end{definition}

Note: as a reviewer helpfully pointed out, we require that $s \cup s'$, $t \cup t'$, and $\tau \cup \tau'$ coincide on common elements. However, this can be assumed w. l. o. g..


\bentley{Do we need typed graph intersection? Or to mention what it means for two graphs to be disjoint?}
\bentley{Is this used in the DPO approach?}

\subsection{Homomorphisms}
\label{subsec:homomorphisms}

For the formal development of our technique, we are interested in relations between typed graphs that preserve some graph structure and vertex/edge type, i.e. homomorphisms.

However, our technique of symbolic execution of transformation rules means that we cannot rely on a trivial homomorphism. Instead our matching must be flexible about how vertices in the pattern graph may match over multiple vertices in the target graph.

\subsubsection*{Typed Graph Homomorphism}

The first typed graph homomorphism we define is standard, where the structure of the pattern graph must be found in the target graph. This is presented for the reader to appreciate the complications required for the next homomorphisms.

\begin{definition}{Typed Graph Homomorphism\\}
\label{def:typed_graph_homomorphism}
\defineggprime

A typed graph homomorphism from $g$ onto $g'$ is a function $f: f_v \cup f_e$ such that:
\begin{itemize}
\item $f_v: V\rightarrow V'$
\item $f_e: E\rightarrow E'$
\item $\forall v_1 \xrightarrow{e} v_2\in E$:
\begin{itemize}
\item Let $ v_1' = f_v(v_1), v_2' = f_v(v_2), e' = f_e(e)$
\item $v_1', v_2' \in V', e' \in E'$
\item $s'(e') = v_1'$, $t'(e') = v_2'$
\item $\mathit{matchesOver}(\tau(v_1), \tau(v_1') \land \\\mathit{matchesOver}(\tau(v_2), \tau(v_2') \land\\ \mathit{matchesOver}(\tau(e), \tau(e')$
\end{itemize}

%, where $\tau(v_1)=\tau'(f(v_1))$, $\tau(v_2)=\tau'(f(v_2))$ and also $\tau(e)=\tau(e')$.
%\item The domain of $f$ is noted $Dom(f)$ and the co-domain of $f$ is noted $CoDom(f)$.
\end{itemize}  
\end{definition}

 When an \emph{injective}\footnote{For a terminology refresh, \textit{injective matching} means there is a one-to-one correspondence between the pattern and target vertices. \textit{Surjective matching} means that all target vertices must be matched by at least one pattern vertex. A \textit{bijection} is when the matching is both injective and surjective.} typed graph homomorphism $f$ exists from $g$ onto $g'$, we write $g \stackrel{inj}{\blacktriangleright} g'$. When a \emph{surjective} typed graph homomorphism $f$ exists from $g$ onto $g'$ we write $g \stackrel{surj}{\blacktriangleright} g'$.

\subsubsection*{Typed Graph Edge Homomorphism}

Our technique also requires a form of graph homomorphism that primarily focuses on matching the edges of the graphs. This homomorphism will be an injective match regarding the edges, but note that a particular vertex in the pattern graph may match onto multiple vertices in the target graph. \bentley{What's the term for this?}

\begin{definition}{Typed Graph Edge Homomorphism\\}
\label{def:typed_graph_edge_homomorphism}
\defineggprime

A typed graph edge homomorphism between $g$ and $g'$ is a function $h: h_v \cup h_e$ such that:
\begin{itemize}
\item $h_v: V'\rightarrow V$ Note that this function has unusual properties:
\begin{itemize}

\item A function from a vertex in the target graph onto a vertex in the pattern graph
\item A partial function, as not all vertices in the target graph will be reflected in the pattern graph
\item Surjective, so that all pattern vertices are matched to by target vertices
\item A minimal function, such that the minimum number of target vertices are matched to each pattern vertex \bentley{Not sure if this is needed.}
\end{itemize}
\item $h_e: E\rightarrow E'$, and is injective
\item $\forall v_1 \xrightarrow{e} v_2\in E$:
\begin{itemize}
\item Let $e' = h_e(e), v_1' = s'(e'), v_2' = t'(e')$
\item $v_1', v_2' \in V', e' \in E'$
\item $v_1 = h_v(v_1'), v_2 = h_v(v_2')$
\item $\mathit{matchesOver}(\tau(v_1), \tau(v_1') \land \\\mathit{matchesOver}(\tau(v_2), \tau(v_2') \land\\ \mathit{matchesOver}(\tau(e), \tau(e')$
\end{itemize}
 
\end{itemize}  
\end{definition}

Again, we wish to highlight the fact that this homomorphism is different than Definition~\ref{def:typed_graph_homomorphism} in the vertex matching function. A vertex in the target graph matches onto a vertex in the pattern graph, with multiple target vertices matching onto the same pattern vertex. 
\bentley{Create diagram to illustrate}

This unusual homomorphism allows our technique to `split' our pattern graph over multiple locations in the target graph. This is critical, as our target graphs are constructed in a way that allows for vertex duplication. That is, two vertices of a particular type in the target graph may only represent one underlying element, as discussed in Section~\ref{sec:abstraction_relation}. Constructing this morphism allows our prover implementation to avoid explicitly creating `disambiguated' graphs where these duplications are resolved.

 When an \emph{injective} typed graph edge homomorphism $f$ exists from $g$ onto $g'$, we write $g \stackrel{inj}{\vartriangleright} g'$. When a \emph{surjective} typed graph edge homomorphism $f$ exists from $g$ onto $g'$ we write $g \stackrel{surj}{\vartriangleright} g'$.



\subsection*{Typed Graph Isomorphism}
Two typed graphs are said to be isomorphic if they have exactly the same shape and related vertices and edges have the same type.


\begin{definition}{Typed Graph Isomorphism\\}
\label{def:typed_graph_isomorphism}
\defineggprime

We say that $g$ and $g'$ are isomorphic, written $g\cong g'$, iff there exists a bijective typed graph homomorphism $f:V\rightarrow V'$ such that $f^{-1}:V'\rightarrow V$ is a typed graph homomorphism.
\end{definition}




\subsubsection*{Transitive Closure}

DSLTrans matching constructs allow for the matching of indirect links, where as described in Section~\ref{subsec:DSLTrans_constructs}, rules may match over indirect paths between elements. This transitive closure allow for the explicit creation of all edges implied by these indirect links to aid in matching.


\begin{definition}{Transitive Closure\\}
\label{def:instance_closure}

Let $g$ be a graph $\langle V,E,(s, t),\tau\rangle \in \textsc{TG}$. Then the transitive closure $g^{*} = \langle V,E',(s', t'),\tau', \VT, \ET' \rangle \in \textsc{TG}$, where:

\begin{itemize}
\item $E' = E \cup v_1\xrightarrow{e''}v_2 | \exists v_1\xrightarrow{e_i}v_i, v_i\xrightarrow{e_j}v_j, \dots, v_k\xrightarrow{e_k}v_2 \land \mathit{isIndirect(e_i)}$
\item \bentley{How to create s, t, and tau?}
\end{itemize}
\end{definition}


Given a graph, its transitive closure includes, besides the original graph, all the edges belonging to the transitive closure of indirect links in that graph. Note that these transitive edges are identified by the function $\mathit{isIndirect}$.

In the definitions that follow we will use the $*$ notation, as in \cref{def:instance_closure}, to denote the transitive closure of our structures.





\subsubsection{Link Homomorphism}

\begin{itemize}
\item Backward links injectively match from contract into PC onto traceability links. Source and target of backward links on contract must match the source and target of the traceability link of the PC.
\end{itemize}

We must also define a function to match link structures, such as backward links and the traceability links (to be discussed).

\begin{definition}{Link Homomorphism\\}
\label{def:link_homomorphism}
Consider two sets of links $L = \{E_{L}, (s_{L}, t_{L})\}$, and $T = \{E_{T}, (s_{T}, t_{T})\}$. Note that these could be backward links or traceability links.

We define an injective homomorphism function $f$ to match $L$ over $T$, such that:

\begin{itemize}
\item $\forall e_L \in E_L:$
\begin{itemize}
\item $\forall e_T \in E_T | f(e_L) = e(T)$
\end{itemize}
\end{itemize} 
\end{definition}

Note that the typing of these links will be given by the component in which they are found.

\subsubsection{Homomorphisms Between Structures}
\label{subsubsec:structure_homomorphism}

In the developments that follow, we will need to find morphisms between different structures.

For example, we may need to find a homomorphism between two structures $S_1 = \langle A, B, L\rangle$ and  $S_2 = \langle A', B', L'\rangle$, where $A, A', B, B' \in TG$ and $L, L'$ are links of the form $\{E, (s, t)\}$.

This overall homomorphism will compose the homomorphism $f(A) = A'$, $g(B) = B'$, $h(L) = L'$, where f and g are the homomorphisms to be found, and h is the link homomorphism.

A reviewer pointed out that we also require that these sub-homomorphisms are consistent with each other. That is, the link homomorphism h must agree with 
the bindings given by f and g.

\bentley{Complete this}



