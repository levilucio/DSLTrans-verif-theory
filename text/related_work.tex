\section{Related Work}
\label{sec:related_work}

\reviewer{citation [40]: Gonzalez and Cabot just published a novel paper at ICMT14.}

In order to analyse the work in the literature that is close to our proposal, we will make use of the study on the formal verification of model transformations proposed in~\cite{DBLP:conf/icst/AmraniLSCDVTC12}. The study uses three dimensions to classify the analysis of model transformations. The dimensions are: 1) the \emph{kind of transformations} considered; 2) the \emph{properties} of transformations that can be verified; and 3) the \emph{verification technique} used.

\subsubsection*{Kind of Transformations Considered} DSLTrans is a graph based transformation language and as such shares its principles with languages such as AGG~\cite{Taentzer2000}, AToM$^3$~\cite{atom3:2002}, VIATRA2~\cite{DBLP:conf/uml/VarroP04}, ATL~\cite{Jouault200831} or VTMS~\cite{DBLP:journals/entcs/LevendovszkyLMC05}. As mentioned previously, DSLTrans' transformation are \emph{terminating} and \emph{confluent} by construction. This is achieved by expressiveness reduction which means that constructs which imply unbounded recursion or non-determinism are avoided. DSLTrans is, to the best of our knowledge, the only graph based transformation language where these properties are enforced by construction.

It is recognized in the literature that \emph{termination} and \emph{confluence} are important properties of model transformations, as these transformations have properties that are easier to understand and analyse. However, termination is undecidable for graph based transformation languages~\cite{DBLP:journals/fuin/Plump98}. This problem has led to a number of proposed termination criteria, as well as criteria analysis techniques, for transformations written in graph based transformation languages~\cite{deLara:2010:ATA:1815798.1815800,EhrigEhrigTaentzerdeLaraVarroVarro2005,Varro-Varro-etAl-2006,J:Bruggink2008,J:Kuster2006}. Confluence is also undecidable for graph based transformation languages~\cite{Plump2005}. As for termination, several confluence criteria and corresponding analysis techniques have been proposed in the literature~\cite{HeckelKT02,J:Kuster2006,J:Lambers-etAl-2006,J:Biermann2011}.

\subsubsection*{Verifiable Properties of Transformations} According to the classification in~\cite{DBLP:conf/icst/AmraniLSCDVTC12} the technique presented in this paper deals with properties that can be regarded as \emph{model syntax relations}. Such properties of a model transformation have to do with the fact that certain elements, or structures, of the input model are necessarily transformed into other elements, or structures, of the output model. 

As early as 2002, Akehurst and Kent have introduced a set of structural relations between the metamodels of the abstract syntax, concrete syntax and semantics domain of a fragment of the UML~\cite{Akehurst:02}. Although they do not use such relations as properties of model transformations, their text introduces the notion of structural relations between a source and a target metamodel for a transformation. In 2007, Narayanan and Karsai propose verifying model transformations by structural correspondence~\cite{Narayanan:07}. In their approach, structural correspondences are defined as pre-condition/post-condition axioms. As the axioms provide an additional level of specification of the transformation, they are written independently from the transformation rules and are predicate logic formulas relying solely on a pair of the transformation's input and output model objects and attributes. The verification of whether such predicates hold is achieved by relying on so-called cross links (also named \emph{traceability links} in~\cite{DBLP:conf/icst/AmraniLSCDVTC12}) that are built between the elements of the input and output transformation model during the transformation's execution.

Although our proposal follows the same basic idea as the work of Narayanan and Karsai, there is one essential difference. Narayanan and Karsai's technique is focused on showing that pre-condition/post-condition axioms hold for one execution of a model transformation, involving one input and its corresponding output model. Thus, according to~\cite{DBLP:conf/icst/AmraniLSCDVTC12} the technique is \emph{transformation dependent} and \emph{input dependent}. In our proposal, we aim at proving structural correspondences for all executions of a model transformation, and base the construction of the properties (or pre-condition/post-condition axioms, using the vocabulary in~\cite{Narayanan:07}) on the source and target metamodel structures. Our approach is thus \emph{transformation dependent} but \emph{input independent} and aims at achieving the proof of the same kind of properties as Narayanan and Karsai propose, but one meta-level above.

In 2009~\cite{DBLP:journals/eceasst/CariouBBD09} Cariou \emph{et al.} study the use of OCL contracts in the verification of model transformations. The approach is also \emph{transformation dependent} and \emph{input dependent} in the sense that it requires an input model and an output model of the transformation. However, the authors provide a good account how to build OCL contracts for model transformations and show how to verify those contracts for endogenous transformations.

Aztalos, Lengyel and Levendovszky have published in 2010 their approach to the verification of model transformations~\cite{DBLP:conf/icst/AsztalosLL10}. They propose an assertion language that allows making structural statements about models at a given point of the execution of the transformation and also statements about the transformation steps themselves. The authors' technique applies to transformations written in the VTMS transformation language~\cite{DBLP:journals/entcs/LevendovszkyLMC05}. The technique consists of transforming VTMS transformation rules and verification assertions into Prolog predicates such that deduction rules encoding VTMS's and the assertion language's semantics can be used on automated Prolog proofs to check whether those assertions hold or not.

The approach resembles ours in the sense that the technique is also \emph{transformation dependent} but \emph{input independent} (the authors call their technique \emph{offline}). The artifacts used in the proofs are also generated from the transformation and the properties to be proved. While it is foreseeable that our \emph{model syntax relations} properties might be expressed by the assertion language proposed by Aztalos \emph{et al.}, the authors provide no account of the scalability of their approach. They mention however that since their approach is based on the generic SWI-Prolog inference engine, there could be a performance bottleneck or the possibility of non-terminating computations. They foresee that a specialised reasoning system might be necessary for their approach to scale.

More recently in 2012 and 2013, Guerra \emph{et al.}~\cite{guerra2013specification} have proposed techniques for the automated verification of model transformations based on visual contracts. Their work describes a rich and well-studied language for describing syntactic relations between input and output models. These pre- and post- condition graphs then are transformed into OCL expressions, which are fed into a constraint-solver to generate test input models for the transformation. Their framework algorithm can then test a transformation on a number of these input models, and verify them by the OCL expressions. The approach is \emph{transformation dependent} and \emph{input independent} and is independent of the transformation language used, which is a feature that we have not found elsewhere in the literature. However the verification technique used by Guerra \emph{et al.} differs fundamentally from ours. Our abstraction over the number of elements of the same type present in the model enables our approach to be exhaustive and allows for correctness proofs, while the approach by Guerra \emph{et al.} is aimed at increasing the level of confidence in a transformation through coverage of test cases. A similar white-box generation approach is also seen in recent work by Gonz{\'a}lez and Cabot~\cite{gonzalez2012atltest}.


Also in 2012 B\"uttner \emph{at al.} have published their work on the verification of ATL transformations~\cite{ButtnerECG12,ButtnerEC12}. In~\cite{ButtnerECG12} the authors translate ATL transformations and their semantics into transformation models in Alloy. They then use Alloy's model finder to search for the negation of a given property that should hold, where the property is expressed as an OCL constraint. As the authors mention, Alloy performs bounded verification and as such it does not guarantee that a counterexample is found if it exists. In~\cite{ButtnerEC12} B\"uttner \emph{at al.} aim at proving model syntax relation properties of ATL transformations expressed as pre-condition/post-condition OCL constraints. In order to do so, the authors provide and use an axiomatisation of ATL's semantics in first order logic. Verification of a given model transformation is achieved by using a HOT to transform the transformation under analysis into additional first order logic axioms. Off-the-shelf SMT solvers such as Z3 and Yices are then used to check whether the pre-condition/post-condition OCL constraints hold.

The approach in~\cite{ButtnerEC12} comes very close to ours as the authors aim at proving the same type of properties in a model independent fashion and can do so exhaustively by using mathematical proofs at an appropriate level of abstraction, which can be seen as symbolic. However, there are several differences with our approach. First, the authors' proofs may require human assistance, depending on the used SAT solver. Also, despite the fact that B\"uttner \emph{at al.} do treat constraints on object attributes, which we do not do, their results are presented for a small (6 rule) transformation and no scalability data, even preliminary, is presented. Finally, contrarily to DSLTrans, ATL does not have explicit formal semantics and because of that B\"uttner \emph{et al.}'s axiomatization of ATL's semantics is tentative. More generally, while the authors' approach requires an intermediate logic representation of the transformation under analysis, our symbolic approach deals directly with transformation rules. This feature can ease the interpretation of analysis of results such as counterexamples and could be in general less error-prone due to the absence of an indirection layer which maps transformation concepts to concepts in the chosen logic. It is interesting to notice that, similarly to our approach, B\"uttner \emph{et al.} have chosen \emph{expressiveness reduction} as a means to work with subset of ATL that is verifiable.

Assertional reasoning in graph transformations has been studied by Habel and colleagues, who have introduced nested conditions as properties of graphs in~\cite{Habel:2009}. The authors formally prove these nested conditions have the expressiveness of first-order graph formulas. Poskitt and Plump later propose in~\cite{PoskittP12} a Hoare-style verification calculus which is anchored on their experimental graph programming language GP. Using this calculus they then go on to prove nested condition properties of a graph-colouring GP program. Our approach shares some resemblances with assertional reasoning in that we also propose a pre-condition/post-condition language and a calculus for proving such properties in DSLTrans. We remark however that the theoretical work in assertional reasoning described above is larger in scope than what we present here and that assertional reasoning results require lifting to more usable graph transformation languages than GP before they can be used in practice. 

\subsubsection*{Verification Technique Used} A different possibility for our work would have been to utilise the GROOVE tool, which can specify, play, and analyse graph transformations~\cite{rensink:2012}. In particular, GROOVE assumes that the states of the systems to be analysed are expressed as graphs and that the system's behaviour is simulated by graph transformation rules that manipulate those graphs.


In~\cite{DBLP:conf/gg/RensinkSV04} Rensink, Schmidt and Varr\'o test whether safety and reachability properties that are expressed as constraints over graphs can be efficiently checked by building the state space for a transformation. The answer is positive, but the authors found state space explosion problems as we did. In order to tackle those issues the tool relies on exploiting the symmetric nature of a problem by investigating isomorphic situations only once. This is very similar to optimisations we have made in our implementation of our approach by maintaining caches throughout path condition construction and property proof. Those caches allow us to avoid rerunning the expensive subgraph isomorphism algorithm as much as possible. It is foreseeable that our approach could make use of the advanced state space construction and recent CTL property checking capabilities of GROOVE. This could be achieved by using GROOVE as the transformation framework for our approach instead of T-CORE. However, at the time of the construction of our tool, fine-grained control of GROOVE transformations via an API as we do with T-CORE did not exist. It was thus infeasible to implement our approach by relying solely on GROOVE's graphical interface.

Still in the context of GROOVE, several studies~\cite{RensinkD06,BauerBKR08,RensinkZ12} have been performed on abstractions that allow coping with the state space explosion when performing model checking of state-based systems modeled as graph transformations. The authors present various abstractions on state graphs that allow reducing their size during model checking while allowing equivalent (or approximate versions of) proofs of temporal logic properties using the abstracted state graphs. Although our technique is also based on abstraction, our main purpose is not to execute concrete graphs in order to examine the state they represent. We rather symbolically represent all transformation executions (resulting from the application of all rules in a DSLTrans transformation to any input model) which are in an abstraction relation with the path conditions, such that we are able to symbolically examine the relations between all of the transformation's inputs and outputs.

Also from the \emph{verification technique} viewpoint, Becker \emph{et al.} propose a technique for checking a dynamic system where state is encoded as a graph~\cite{Becker:2006:SIV:1134285.1134297}. They also use model transformations to simulate the system's progression and aim at verifying that no unsafe states are reached as part of the system's behavior. In this sense Becker \emph{et al.}'s approach is \emph{transformation dependent} and \emph{input independent}, as an infinite amount of initial graphs needs to be considered. However, instead of generating the exhaustive state space as is done with GROOVE, the authors follow a different strategy by checking that no unsafe states of the system can be reached. They do so by searching for unsafe states as counterexamples of invariants encoded in the transformation rules. The analysis is performed symbolically on the application transformation rules and as such resembles our symbolic execution technique.
However, rather than being generically applicable to model transformations, possibly exogenous, the approach is geared towards the mechatronic domain and graph transformations are used as a means to encode the dynamic structural adaptation of such systems.
The applicability or efficiency of Becker \emph{et al.}'s technique when applied to the verification of model syntax relations in model transformations remains to be studied.